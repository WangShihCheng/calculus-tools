<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cross-Section æˆªé¢æ³•è¦–è¦ºåŒ–</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.98);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        #controls.collapsed {
            transform: translateX(-420px);
            opacity: 0.3;
        }
        #toggleBtn {
            position: absolute;
            right: -45px;
            top: 20px;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            border: none;
            border-radius: 0 8px 8px 0;
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        #toggleBtn:hover {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            transform: scale(1.1);
        }
        h1 {
            color: #1e3c72;
            margin-bottom: 8px;
            font-size: 26px;
        }
        .subtitle {
            color: #666;
            font-size: 13px;
            margin-bottom: 20px;
        }
        .section-type {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        .type-btn {
            padding: 12px 8px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
        }
        .type-btn.active {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border-color: #1e3c72;
        }
        label {
            display: block;
            margin: 15px 0 5px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            transition: border-color 0.3s;
        }
        input:focus {
            outline: none;
            border-color: #2a5298;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        button.main-btn {
            width: 100%;
            padding: 14px;
            margin-top: 15px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
        }
        button.main-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 60, 114, 0.4);
        }
        .result {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
        }
        .result h3 {
            font-size: 16px;
            margin-bottom: 10px;
        }
        .result .value {
            font-size: 28px;
            font-weight: bold;
            margin: 8px 0;
        }
        .formula {
            font-family: 'Courier New', monospace;
            background: rgba(255,255,255,0.2);
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            margin-top: 8px;
        }
        .examples {
            background: #e8f4f8;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            border: 2px solid #2a5298;
        }
        .examples h4 {
            color: #1e3c72;
            font-size: 13px;
            margin-bottom: 8px;
        }
        .example-btn {
            display: inline-block;
            padding: 6px 12px;
            margin: 4px;
            background: white;
            border: 2px solid #2a5298;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            color: #1e3c72;
            transition: all 0.2s;
        }
        .example-btn:hover {
            background: #2a5298;
            color: white;
        }
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 12px;
            border: 2px solid #ef5350;
        }
        .animation-controls {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            border: 2px solid #4caf50;
        }
        .animation-controls h4 {
            color: #2e7d32;
            font-size: 15px;
            margin-bottom: 12px;
        }
        .animation-progress {
            background: #fff;
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            border: 2px solid #81c784;
        }
        .progress-bar {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin: 8px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50 0%, #81c784 100%);
            transition: width 0.1s linear;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        .anim-btn-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        .anim-btn {
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }
        .anim-btn.play {
            background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
            color: white;
        }
        .anim-btn.pause {
            background: linear-gradient(135deg, #ff9800 0%, #ffb74d 100%);
            color: white;
        }
        .anim-btn.stop {
            background: linear-gradient(135deg, #f44336 0%, #ef5350 100%);
            color: white;
        }
        .anim-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
        }
        .anim-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .speed-control {
            margin-top: 10px;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin-right: 8px;
        }
        .loop-control {
            display: flex;
            align-items: center;
            margin-top: 10px;
            padding: 8px;
            background: white;
            border-radius: 6px;
        }
        .info {
            background: #fff3e0;
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 12px;
            line-height: 1.6;
            color: #e65100;
            border: 2px solid #ffb74d;
        }
        #info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            font-size: 13px;
            color: #333;
            max-width: 350px;
            line-height: 1.8;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <button id="toggleBtn" onclick="toggleControls()">â—€</button>
        
        <h1>ğŸ“ Cross-Section æˆªé¢æ³•</h1>
        <p class="subtitle">Volume by Cross-Sections</p>
        
        <div class="examples">
            <h4>ğŸ“š ç¯„ä¾‹ï¼š</h4>
            <span class="example-btn" onclick="loadExample(0)">é¡Œ1: æ­£æ–¹å½¢</span>
            <span class="example-btn" onclick="loadExample(1)">é¡Œ5a: ç­‰é‚Šä¸‰è§’</span>
            <span class="example-btn" onclick="loadExample(2)">é¡Œ5b: æ­£æ–¹å½¢</span>
            <span class="example-btn" onclick="loadExample(3)">é¡Œ8b: åŠåœ“</span>
        </div>
        
        <label>æˆªé¢é¡å‹ï¼š</label>
        <div class="section-type">
            <div class="type-btn active" onclick="setSectionType('square')">
                æ­£æ–¹å½¢<br>Square
            </div>
            <div class="type-btn" onclick="setSectionType('triangle')">
                ç­‰é‚Šä¸‰è§’<br>Triangle
            </div>
            <div class="type-btn" onclick="setSectionType('semicircle')">
                åŠåœ“<br>Semicircle
            </div>
        </div>
        
        <label>ä¸Šæ›²ç·š y_top =</label>
        <input type="text" id="topFunc" value="sqrt(x)" placeholder="sqrt(x), 2, sin(x)">
        
        <label>ä¸‹æ›²ç·š y_bottom =</label>
        <input type="text" id="bottomFunc" value="-sqrt(x)" placeholder="-sqrt(x), 0, -sin(x)">
        
        <div class="grid-2">
            <div>
                <label>ä¸‹ç•Œ a =</label>
                <input type="text" id="lowerBound" value="0">
            </div>
            <div>
                <label>ä¸Šç•Œ b =</label>
                <input type="text" id="upperBound" value="4">
            </div>
        </div>
        
        <label>åˆ‡ç‰‡æ•¸é‡ï¼š<span id="sliceValue">30</span></label>
        <input type="range" id="sliceCount" min="10" max="80" value="30" 
               oninput="updateSliceCount(this.value)">
        
        <button class="main-btn" onclick="generateSolid()">ğŸ”„ ç”Ÿæˆå®Œæ•´å›ºé«”</button>
        
        <!-- å‹•ç•«æ§åˆ¶ -->
        <div class="animation-controls">
            <h4>ğŸ¬ å‹•ç•«æ§åˆ¶</h4>
            
            <div class="animation-progress" id="animProgress" style="display:none;">
                <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                    ç•¶å‰åˆ‡ç‰‡ï¼š<strong id="currentSlices">0</strong> / <strong id="totalSlices">30</strong>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%;">0%</div>
                </div>
            </div>
            
            <div class="anim-btn-group">
                <button class="anim-btn play" onclick="startAnimation()">â–¶ æ’­æ”¾</button>
                <button class="anim-btn pause" onclick="pauseAnimation()" disabled>â¸ æš«åœ</button>
                <button class="anim-btn stop" onclick="stopAnimation()" disabled>â¹ åœæ­¢</button>
            </div>
            
            <div class="speed-control">
                <label style="font-size: 12px;">é€Ÿåº¦ï¼š<span id="speedLabel">ä¸­é€Ÿ</span></label>
                <input type="range" id="animSpeed" min="1" max="3" value="2" 
                       oninput="updateSpeed(this.value)">
            </div>
            
            <div class="loop-control">
                <input type="checkbox" id="loopCheck">
                <label style="margin: 0; font-size: 13px; color: #2e7d32;">é‡è¤‡æ’­æ”¾</label>
            </div>
        </div>
        
        <div id="errorMsg" class="error" style="display:none;"></div>
        
        <div class="result" id="result" style="display:none;">
            <h3>è¨ˆç®—é«”ç©</h3>
            <div class="value" id="volumeValue">0</div>
            <div class="formula" id="formulaDisplay"></div>
        </div>
        
        <div class="info">
            <strong>ğŸ’¡ èªªæ˜ï¼š</strong><br>
            â€¢ æˆªé¢å‚ç›´æ–¼ x è»¸<br>
            â€¢ åŸºåº•é•·åº¦ = ä¸Šæ›²ç·š - ä¸‹æ›²ç·š<br>
            â€¢ æ­£æ–¹å½¢ï¼šA = sÂ²<br>
            â€¢ ç­‰é‚Šä¸‰è§’ï¼šA = (âˆš3/4)sÂ²<br>
            â€¢ åŠåœ“ï¼šA = (Ï€/8)sÂ²
        </div>
    </div>
    
    <div id="info-panel">
        <strong>ğŸ¨ æ“ä½œèªªæ˜</strong><br>
        <strong>æ‹–æ›³ï¼š</strong>æ—‹è½‰ 3D è¦–è§’<br>
        <strong>æ»¾è¼ªï¼š</strong>ç¸®æ”¾ç•«é¢<br>
        <strong>å‹•ç•«ï¼š</strong>è§€çœ‹åˆ‡ç‰‡é€å€‹å †ç–Š<br>
        <strong>é‡è¤‡æ’­æ”¾ï¼š</strong>è‡ªå‹•å¾ªç’°å‹•ç•«<br>
        <br>
        <strong>ğŸ“– Cross-Section Methodï¼š</strong><br>
        å°‡å›ºé«”åˆ‡æˆè¨±å¤šè–„ç‰‡ï¼Œè¨ˆç®—æ¯ç‰‡é¢ç©ï¼Œå†ç©åˆ†æ±‚é«”ç©ã€‚
    </div>

    <script>
        let scene, camera, renderer, solidGroup;
        let currentSectionType = 'square';
        let controlsCollapsed = false;
        
        // å‹•ç•«è®Šæ•¸
        let isAnimating = false;
        let animationPaused = false;
        let currentSliceIndex = 0;
        let animationSpeed = 50;
        let animationInterval = null;
        let cachedData = null;
        let isLooping = false;
        
        const examples = [
            // é¡Œ1: æ­£æ–¹å½¢æˆªé¢
            { top: 'sqrt(x)', bottom: '-sqrt(x)', a: '0', b: '4', type: 'square' },
            // é¡Œ5a: ç­‰é‚Šä¸‰è§’å½¢æˆªé¢
            { top: '2*sqrt(sin(x))', bottom: '0', a: '0', b: 'pi', type: 'triangle' },
            // é¡Œ5b: æ­£æ–¹å½¢æˆªé¢
            { top: '2*sqrt(sin(x))', bottom: '0', a: '0', b: 'pi', type: 'square' },
            // é¡Œ8b: åŠåœ“æˆªé¢
            { top: 'sqrt(x)', bottom: 'x/2', a: '0', b: '4', type: 'semicircle' }
        ];
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            const btn = document.getElementById('toggleBtn');
            controlsCollapsed = !controlsCollapsed;
            
            if (controlsCollapsed) {
                controls.classList.add('collapsed');
                btn.textContent = 'â–¶';
            } else {
                controls.classList.remove('collapsed');
                btn.textContent = 'â—€';
            }
        }
        
        function updateSliceCount(value) {
            document.getElementById('sliceValue').textContent = value;
            document.getElementById('totalSlices').textContent = value;
        }
        
        function updateSpeed(value) {
            const speeds = ['æ…¢é€Ÿ', 'ä¸­é€Ÿ', 'å¿«é€Ÿ'];
            const speedMs = [100, 50, 20];
            document.getElementById('speedLabel').textContent = speeds[value - 1];
            animationSpeed = speedMs[value - 1];
        }
        
        function setSectionType(type) {
            currentSectionType = type;
            document.querySelectorAll('.type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        function loadExample(index) {
            const ex = examples[index];
            document.getElementById('topFunc').value = ex.top;
            document.getElementById('bottomFunc').value = ex.bottom;
            document.getElementById('lowerBound').value = ex.a;
            document.getElementById('upperBound').value = ex.b;
            
            // è¨­ç½®æˆªé¢é¡å‹
            currentSectionType = ex.type;
            document.querySelectorAll('.type-btn').forEach((btn, idx) => {
                btn.classList.remove('active');
                if ((ex.type === 'square' && idx === 0) ||
                    (ex.type === 'triangle' && idx === 1) ||
                    (ex.type === 'semicircle' && idx === 2)) {
                    btn.classList.add('active');
                }
            });
            
            generateSolid();
        }
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f4f8);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 8, 10);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.4);
            pointLight.position.set(-10, 5, -10);
            scene.add(pointLight);
            
            addAxes();
            setupControls();
            animate();
            generateSolid();
        }
        
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;
            
            context.fillStyle = color;
            context.font = 'Bold 80px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.8, 0.8, 1);
            
            return sprite;
        }
        
        function addAxes() {
            const axesGroup = new THREE.Group();
            const axisLength = 14;
            const labelPositionOffset = 8;
            
            const createAxis = (color, rotation) => {
                const geometry = new THREE.CylinderGeometry(0.03, 0.03, axisLength, 16);
                const material = new THREE.MeshBasicMaterial({ color });
                const axis = new THREE.Mesh(geometry, material);
                if (rotation) axis.rotation[rotation.axis] = rotation.angle;
                
                if (rotation && rotation.axis === 'z') axis.position.x = axisLength / 2;
                else if (rotation && rotation.axis === 'x') axis.position.z = axisLength / 2;
                else if (!rotation) axis.position.y = axisLength / 2;
                
                return axis;
            };
            
            axesGroup.add(createAxis(0xff0000, { axis: 'z', angle: Math.PI / 2 }));
            axesGroup.add(createAxis(0x00ff00, null));
            axesGroup.add(createAxis(0x0000ff, { axis: 'x', angle: Math.PI / 2 }));
            
            const xLabel = createTextSprite('X', '#FF0000');
            xLabel.position.set(labelPositionOffset, 0, 0);
            axesGroup.add(xLabel);
            
            const yLabel = createTextSprite('Y', '#00FF00');
            yLabel.position.set(0, labelPositionOffset, 0);
            axesGroup.add(yLabel);
            
            const zLabel = createTextSprite('Z', '#0000FF');
            zLabel.position.set(0, 0, labelPositionOffset);
            axesGroup.add(zLabel);
            
            scene.add(axesGroup);
            
            const gridHelper = new THREE.GridHelper(14, 28, 0xcccccc, 0xe0e0e0);
            scene.add(gridHelper);
        }
        
        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            const rotationSpeed = 0.005;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    const radius = Math.sqrt(
                        camera.position.x ** 2 + 
                        camera.position.y ** 2 + 
                        camera.position.z ** 2
                    );
                    
                    const theta = Math.atan2(camera.position.z, camera.position.x);
                    const phi = Math.acos(camera.position.y / radius);
                    
                    const newTheta = theta - deltaX * rotationSpeed;
                    const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi - deltaY * rotationSpeed));
                    
                    camera.position.x = radius * Math.sin(newPhi) * Math.cos(newTheta);
                    camera.position.y = radius * Math.cos(newPhi);
                    camera.position.z = radius * Math.sin(newPhi) * Math.sin(newTheta);
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY * 0.001;
                const radius = Math.sqrt(
                    camera.position.x ** 2 + 
                    camera.position.y ** 2 + 
                    camera.position.z ** 2
                );
                const newRadius = Math.max(5, Math.min(30, radius + delta * 10));
                const scale = newRadius / radius;
                
                camera.position.x *= scale;
                camera.position.y *= scale;
                camera.position.z *= scale;
            });
        }
        
        function evaluateFunction(expr, variable) {
            try {
                const scope = { 
                    x: variable,
                    e: Math.E,
                    pi: Math.PI,
                    Ï€: Math.PI
                };
                
                let processed = expr
                    .replace(/\bpi\b/gi, 'pi')
                    .replace(/Ï€/g, 'pi')
                    .replace(/log\(/g, 'log10(')
                    .replace(/ln\(/g, 'log(');
                
                return math.evaluate(processed, scope);
            } catch (e) {
                throw new Error('ç„¡æ³•è¨ˆç®—å‡½æ•¸: ' + expr);
            }
        }
        
        function parseBoundary(boundStr) {
            try {
                const scope = { 
                    e: Math.E,
                    pi: Math.PI,
                    Ï€: Math.PI
                };
                
                let processed = boundStr
                    .replace(/\bpi\b/gi, 'pi')
                    .replace(/Ï€/g, 'pi');
                
                return math.evaluate(processed, scope);
            } catch (e) {
                throw new Error('ç„¡æ³•è§£æé‚Šç•Œ: ' + boundStr);
            }
        }
        
        function getCrossSectionArea(baseLength, type) {
            const s = baseLength;
            switch(type) {
                case 'square':
                    return s * s;
                case 'triangle':
                    return (Math.sqrt(3) / 4) * s * s;
                case 'semicircle':
                    return (Math.PI / 8) * s * s;
                default:
                    return s * s;
            }
        }
        
        function createCrossSection(x, baseLength, type) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            const s = baseLength;
            const halfS = s / 2;
            
            switch(type) {
                case 'square':
                    // æ­£æ–¹å½¢ï¼ˆåœ¨ yz å¹³é¢ï¼‰
                    vertices.push(
                        x, -halfS, -halfS,
                        x, halfS, -halfS,
                        x, halfS, halfS,
                        x, -halfS, halfS
                    );
                    indices.push(0, 1, 2, 0, 2, 3);
                    break;
                    
                case 'triangle':
                    // ç­‰é‚Šä¸‰è§’å½¢ï¼ˆé ‚é»æœä¸Šï¼‰
                    const height = (Math.sqrt(3) / 2) * s;
                    vertices.push(
                        x, -halfS, 0,
                        x, halfS, 0,
                        x, 0, height
                    );
                    indices.push(0, 1, 2);
                    break;
                    
                case 'semicircle':
                    // åŠåœ“ï¼ˆç›´å¾‘æ°´å¹³ï¼‰
                    const radius = s / 2;
                    const segments = 20;
                    vertices.push(x, -radius, 0);
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI;
                        const y = -radius + Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        vertices.push(x, y, z);
                    }
                    for (let i = 1; i <= segments; i++) {
                        indices.push(0, i, i + 1);
                    }
                    break;
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            return geometry;
        }
        
        function prepareData() {
            const topFunc = document.getElementById('topFunc').value;
            const bottomFunc = document.getElementById('bottomFunc').value;
            const aStr = document.getElementById('lowerBound').value;
            const bStr = document.getElementById('upperBound').value;
            const sliceCount = parseInt(document.getElementById('sliceCount').value);
            
            const a = parseBoundary(aStr);
            const b = parseBoundary(bStr);
            
            if (a >= b) {
                throw new Error('ä¸Šç•Œå¿…é ˆå¤§æ–¼ä¸‹ç•Œ');
            }
            
            return { topFunc, bottomFunc, a, b, aStr, bStr, sliceCount, sectionType: currentSectionType };
        }
        
        function calculateExactIntegral(topExpr, bottomExpr, a, b, sectionType) {
            // å˜—è©¦ç²¾ç¢ºè¨ˆç®—
            const cleanTop = topExpr.replace(/\s/g, '').toLowerCase();
            const cleanBottom = bottomExpr.replace(/\s/g, '').toLowerCase();
            
            // è¨ˆç®—åŸºåº•é•·åº¦å‡½æ•¸ s(x) = top - bottom
            let baseLengthExpr = '';
            
            // ç‰¹æ®Šæƒ…æ³è™•ç†
            // é¡Œ1: sqrt(x) - (-sqrt(x)) = 2*sqrt(x)
            if (cleanTop === 'sqrt(x)' && cleanBottom === '-sqrt(x)') {
                baseLengthExpr = '2*sqrt(x)';
            }
            // é¡Œ5: 2*sqrt(sin(x)) - 0 = 2*sqrt(sin(x))
            else if (cleanTop.includes('sqrt(sin(x))') && cleanBottom === '0') {
                baseLengthExpr = cleanTop;
            }
            // é¡Œ8b: sqrt(x) - x/2
            else if (cleanTop === 'sqrt(x)' && cleanBottom === 'x/2') {
                baseLengthExpr = 'sqrt(x)-x/2';
            }
            
            // æ ¹æ“šæˆªé¢é¡å‹è¨ˆç®—é¢ç©
            let areaCoeff = 1;
            let areaName = 'sÂ²';
            switch(sectionType) {
                case 'square':
                    areaCoeff = 1;
                    areaName = 'sÂ²';
                    break;
                case 'triangle':
                    areaCoeff = Math.sqrt(3) / 4;
                    areaName = '(âˆš3/4)sÂ²';
                    break;
                case 'semicircle':
                    areaCoeff = Math.PI / 8;
                    areaName = '(Ï€/8)sÂ²';
                    break;
            }
            
            // å˜—è©¦ç²¾ç¢ºç©åˆ†
            // é¡Œ1: æ­£æ–¹å½¢, s=2âˆšx, A=4x, âˆ«â‚€â´ 4x dx = [2xÂ²]â‚€â´ = 32
            if (baseLengthExpr === '2*sqrt(x)' && sectionType === 'square' && a === 0 && b === 4) {
                return { exact: true, symbolic: '32', numeric: 32 };
            }
            
            // é¡Œ5a: ç­‰é‚Šä¸‰è§’, s=2âˆšsin(x), A=(âˆš3/4)(4sin(x))=âˆš3Â·sin(x), âˆ«â‚€^Ï€ âˆš3Â·sin(x) dx = 2âˆš3
            if (cleanTop === '2*sqrt(sin(x))' && sectionType === 'triangle' && a === 0 && Math.abs(b - Math.PI) < 0.01) {
                return { exact: true, symbolic: '2âˆš3', numeric: 2 * Math.sqrt(3) };
            }
            
            // é¡Œ5b: æ­£æ–¹å½¢, s=2âˆšsin(x), A=4sin(x), âˆ«â‚€^Ï€ 4sin(x) dx = 8
            if (cleanTop === '2*sqrt(sin(x))' && sectionType === 'square' && a === 0 && Math.abs(b - Math.PI) < 0.01) {
                return { exact: true, symbolic: '8', numeric: 8 };
            }
            
            // é¡Œ8b: åŠåœ“, s=âˆšx-x/2, A=(Ï€/8)(âˆšx-x/2)Â²
            // âˆ«â‚€â´ (Ï€/8)(x - x^(3/2) + xÂ²/4) dx = Ï€/15
            if (baseLengthExpr === 'sqrt(x)-x/2' && sectionType === 'semicircle' && a === 0 && b === 4) {
                return { exact: true, symbolic: 'Ï€/15', numeric: Math.PI / 15 };
            }
            
            return null; // ç„¡æ³•ç²¾ç¢ºè¨ˆç®—
        }
        

        function calculateNumericalVolume(data, intervals = 240) {
            const { topFunc, bottomFunc, a, b } = data;
            let n = Math.max(20, Math.floor(intervals));
            if (n % 2 !== 0) n += 1; // Simpson's rule requires even intervals
            const h = (b - a) / n;

            const areaAt = (x) => {
                const yTop = evaluateFunction(topFunc, x);
                const yBottom = evaluateFunction(bottomFunc, x);
                const baseLength = Math.abs(yTop - yBottom);
                if (!isFinite(baseLength) || baseLength <= 0) return 0;
                return getCrossSectionArea(baseLength, data.sectionType);
            };

            let sum = areaAt(a) + areaAt(b);
            for (let i = 1; i < n; i++) {
                const coeff = i % 2 === 0 ? 2 : 4;
                sum += coeff * areaAt(a + i * h);
            }
            return (h / 3) * sum;
        }

        function generateSolidWithSlices(data, numSlices) {
            if (solidGroup) scene.remove(solidGroup);
            solidGroup = new THREE.Group();
            
            const { topFunc, bottomFunc, a, b, sliceCount } = data;
            const step = (b - a) / sliceCount;
            
            let volume = 0;
            
            for (let i = 0; i < numSlices && i < sliceCount; i++) {
                const x = a + i * step;
                const yTop = evaluateFunction(topFunc, x);
                const yBottom = evaluateFunction(bottomFunc, x);
                const baseLength = Math.abs(yTop - yBottom);
                
                if (!isFinite(baseLength) || baseLength <= 0) continue;
                
                const area = getCrossSectionArea(baseLength, data.sectionType);
                volume += area * step;
                
                const sectionGeom = createCrossSection(x, baseLength, data.sectionType);
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(i / sliceCount, 0.7, 0.6),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.85,
                    flatShading: false
                });
                
                const mesh = new THREE.Mesh(sectionGeom, material);
                solidGroup.add(mesh);
                
                // æ·»åŠ é‚Šæ¡†
                const edges = new THREE.EdgesGeometry(sectionGeom);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 })
                );
                solidGroup.add(line);
            }
            
            scene.add(solidGroup);
            return volume;
        }
        
        function generateSolid() {
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.style.display = 'none';
            
            try {
                cachedData = prepareData();
                
                // å˜—è©¦ç²¾ç¢ºç©åˆ†
                const exactResult = calculateExactIntegral(
                    cachedData.topFunc,
                    cachedData.bottomFunc,
                    cachedData.a,
                    cachedData.b,
                    cachedData.sectionType
                );
                
                let volume, displayText;
                
                if (exactResult && exactResult.exact) {
                    volume = exactResult.numeric;
                    displayText = exactResult.symbolic;
                } else {
                    volume = calculateNumericalVolume(cachedData, Math.max(200, cachedData.sliceCount * 6));
                    displayText = volume.toFixed(6);
                }
                
                document.getElementById('result').style.display = 'block';
                document.getElementById('volumeValue').textContent = displayText;
                
                let areaFormula = '';
                switch(cachedData.sectionType) {
                    case 'square': areaFormula = 'sÂ²'; break;
                    case 'triangle': areaFormula = '(âˆš3/4)sÂ²'; break;
                    case 'semicircle': areaFormula = '(Ï€/8)sÂ²'; break;
                }
                
                document.getElementById('formulaDisplay').textContent = 
                    `V = âˆ«[${cachedData.aStr}, ${cachedData.bStr}] A(x) dx, A(x) = ${areaFormula} (æ•¸å€¼: Simpson)`;
                
                // ç”Ÿæˆè¦–è¦ºåŒ–
                generateSolidWithSlices(cachedData, cachedData.sliceCount);
                
            } catch (e) {
                errorMsg.textContent = 'éŒ¯èª¤: ' + e.message;
                errorMsg.style.display = 'block';
                document.getElementById('result').style.display = 'none';
            }
        }
        
        function startAnimation() {
            if (isAnimating && !animationPaused) return;
            
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.style.display = 'none';
            
            try {
                if (!cachedData) {
                    cachedData = prepareData();
                }
                
                if (!animationPaused) {
                    currentSliceIndex = 0;
                }
                
                isAnimating = true;
                animationPaused = false;
                isLooping = document.getElementById('loopCheck').checked;
                
                document.getElementById('animProgress').style.display = 'block';
                document.getElementById('totalSlices').textContent = cachedData.sliceCount;
                
                updateAnimationButtons(true);
                
                animationInterval = setInterval(() => {
                    if (currentSliceIndex <= cachedData.sliceCount) {
                        generateSolidWithSlices(cachedData, currentSliceIndex);
                        
                        document.getElementById('currentSlices').textContent = currentSliceIndex;
                        const percentage = (currentSliceIndex / cachedData.sliceCount * 100).toFixed(0);
                        document.getElementById('progressFill').style.width = percentage + '%';
                        document.getElementById('progressFill').textContent = percentage + '%';
                        
                        if (currentSliceIndex === cachedData.sliceCount) {
                            const exactResult = calculateExactIntegral(
                                cachedData.topFunc,
                                cachedData.bottomFunc,
                                cachedData.a,
                                cachedData.b,
                                cachedData.sectionType
                            );
                            const isExact = exactResult && exactResult.exact;
                            const preciseVolume = isExact
                                ? exactResult.numeric
                                : calculateNumericalVolume(cachedData, Math.max(200, cachedData.sliceCount * 6));
                            document.getElementById('result').style.display = 'block';
                            document.getElementById('volumeValue').textContent = isExact
                                ? exactResult.symbolic
                                : preciseVolume.toFixed(6);
                        }
                        
                        currentSliceIndex++;
                    } else {
                        if (isLooping) {
                            currentSliceIndex = 0;
                        } else {
                            stopAnimation();
                        }
                    }
                }, animationSpeed);
                
            } catch (e) {
                errorMsg.textContent = 'éŒ¯èª¤: ' + e.message;
                errorMsg.style.display = 'block';
                stopAnimation();
            }
        }
        
        function pauseAnimation() {
            if (!isAnimating) return;
            
            animationPaused = true;
            clearInterval(animationInterval);
            updateAnimationButtons(false);
        }
        
        function stopAnimation() {
            isAnimating = false;
            animationPaused = false;
            clearInterval(animationInterval);
            currentSliceIndex = 0;
            updateAnimationButtons(false);
            
            document.getElementById('currentSlices').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            
            if (cachedData) {
                generateSolidWithSlices(cachedData, 0);
            }
        }
        
        function updateAnimationButtons(playing) {
            const playBtn = document.querySelectorAll('.anim-btn.play')[0];
            const pauseBtn = document.querySelectorAll('.anim-btn.pause')[0];
            const stopBtn = document.querySelectorAll('.anim-btn.stop')[0];
            
            if (playing) {
                playBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;
            } else {
                playBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        init();
    </script>
</body>
</html>